#include "VSECC.h"

VSECCStatus_t current_state;
//extern VseccCyclicCount_t Gun1VseccCyclicCount;
/**
 * @brief Send a PECCStatus1 message to VSECC
 */

static uint8_t VSECCRegularityCheck[10]={0,0,0,0,0,0,0,0,0,0};
static uint8_t VSECCCount[10]={0,0,0,0,0,0,0,0,0,0};
// Object for MSG which will be received from VSECC
//
//*****************************************************************************
// VSECCRXCANOBJSet
//
// @brief Configures CAN Receive Message Objects
//
// This function sets up multiple CAN message objects to receive messages
// from different sources. Each message object is configured for a specific
// CAN ID and uses a standard frame format with ID filtering enabled.
//
// The function calls `CANMSGObjectSetup()` to initialize four receive
// message objects:
//   - `CANOBJ_VSECC1BASE`: Listens for messages(charging-related messages) from `CTRLGUN1`.
//   - `CANOBJ_VSECC2BASE`: Listens for messages(charging-related messages) from `CTRLGUN2`.
//   - `CANOBJ_VSECC1BASEIO`: Listens for messages(external hardware control) from `BASE_ADDRESS_IO_G1`.
//   - `CANOBJ_VSECC2BASEIO`: Listens for messages(external hardware control) from `BASE_ADDRESS_IO_G2`.
//
// Each message object is configured to:
//   - Receive standard frame messages (`STDFrame`).
//   - Use an identifier mask (`MASKFORBASE`) for filtering.
//   - Enable receive interrupts (`CAN_MSG_OBJ_RX_INT_ENABLE`).
//   - Filter messages based on ID (`CAN_MSG_OBJ_USE_ID_FILTER`).
//
//
//   @param uint32_t CANBASE   - Base address of the CAN
//   @param uint8_t ObjectID   - Message Object ID
//   @param uint32_t BaseID    - Message Identifier (CAN ID)
//   @param uint8_t FrameType  - Type of CAN frame, Standard (11-bit ID) or Extended (29-bit ID)
//   @param uint8_t ObjectType - Type of Message Object, transmission (TX) or reception (RX)
//   @param uint32_t MaskID    - Mask Identifier for Filtering
//   @param uint32_t IntName   - Interrupt Configuration
//
//
//
// @return None.
//
//*****************************************************************************/
void VSECCRXCANOBJSet()
{
   /* CANMSGObjectSetup(VSECC_CAN_BASE,
                      CANOBJ_VSECC1BASE,
                      CTRLGUN1,STDFrame,
                      CANOBJECTTYPERX,
                      MASKFORBASE,
                      CAN_MSG_OBJ_RX_INT_ENABLE|CAN_MSG_OBJ_USE_ID_FILTER);*/

    CANMSGObjectSetup(VSECC_CAN_BASE,CANOBJ_VSECC2BASE,
                      CTRLGUN2,STDFrame,
                      CANOBJECTTYPERX,MASKFORBASE,
                      CAN_MSG_OBJ_RX_INT_ENABLE|CAN_MSG_OBJ_USE_ID_FILTER);

   /* CANMSGObjectSetup(VSECC_CAN_BASE,CANOBJ_VSECC1BASEIO,
                      BASE_ADDRESS_IO_G1,STDFrame,
                      CANOBJECTTYPERX,MASKFORBASE,
                      CAN_MSG_OBJ_RX_INT_ENABLE|CAN_MSG_OBJ_USE_ID_FILTER);*/

    CANMSGObjectSetup(VSECC_CAN_BASE,CANOBJ_VSECC2BASEIO,
                      BASE_ADDRESS_IO_G2,STDFrame,
                       CANOBJECTTYPERX,MASKFORBASE,
                       CAN_MSG_OBJ_RX_INT_ENABLE|CAN_MSG_OBJ_USE_ID_FILTER);

}

// OBJECT for MSGS which we are going to send to VSECC
//*****************************************************************************
//
//! VSECCTXCANOBJSet
//!
//! @brief Configures CAN Transmit Message Objects
//!
//! @param BaseAddress is the base CAN message identifier for a specific control gun (CTRLGUN1 or CTRLGUN2).
//!
//! This function sets up multiple CAN transmit message objects for a specific control gun (CTRLGUN1 or CTRLGUN2).
//! Each message object corresponds to a different status or limit related to the charging process.
//!
//! The function configures message objects using the `CANMSGObjectSetup()` function, setting them as transmit (TX)
//! objects with standard CAN frames. The message IDs are generated by adding predefined offsets to the BaseAddress.
//!
//! @return None.
//
//*****************************************************************************
void VSECCTXCANOBJSet(uint32_t BaseAddress)
{
    if (BaseAddress ==CTRLGUN1)
    {
        CANMSGObjectSetup(VSECC_CAN_BASE,CANOBJ_G1PECCSTATUS1,
                          BaseAddress+PECC_STATUS1_OFFSET,STDFrame,
                          CANOBJECTTYPETX,0,
                          CAN_MSG_OBJ_NO_FLAGS);

        CANMSGObjectSetup(VSECC_CAN_BASE,CANOBJ_G1PECCSTATUS2,
                          BaseAddress+PECC_STATUS2_OFFSET,STDFrame,
                          CANOBJECTTYPETX,0,
                          CAN_MSG_OBJ_NO_FLAGS);

        CANMSGObjectSetup(VSECC_CAN_BASE,CANOBJ_G1PECCLIMITS1,
                          BaseAddress+PECC_LIMITS1_OFFSET,STDFrame,
                          CANOBJECTTYPETX,0,
                          CAN_MSG_OBJ_NO_FLAGS);

        CANMSGObjectSetup(VSECC_CAN_BASE,CANOBJ_G1PECCLIMITS2,
                          BaseAddress+PECC_LIMITS2_OFFSET,STDFrame,
                          CANOBJECTTYPETX,0,
                          CAN_MSG_OBJ_NO_FLAGS);

        CANMSGObjectSetup(VSECC_CAN_BASE,CANOBJ_G1PECCLIMITS3,
                          BaseAddress+PECC_LIMITS3_OFFSET,STDFrame,
                          CANOBJECTTYPETX,0,
                          CAN_MSG_OBJ_NO_FLAGS);

        CANMSGObjectSetup(VSECC_CAN_BASE,CANOBJ_G1STOPCHARGING,
                          BaseAddress+STOP_CHARGING_OFFSET,STDFrame,
                          CANOBJECTTYPETX,0,
                          CAN_MSG_OBJ_NO_FLAGS);
    }
    if (BaseAddress ==CTRLGUN2)
    {
        CANMSGObjectSetup(VSECC_CAN_BASE,CANOBJ_G2PECCSTATUS1,
                                  BaseAddress+PECC_STATUS1_OFFSET,STDFrame,
                                  CANOBJECTTYPETX,0,
                                  CAN_MSG_OBJ_NO_FLAGS);

        CANMSGObjectSetup(VSECC_CAN_BASE,CANOBJ_G2PECCSTATUS2,
                          BaseAddress+PECC_STATUS2_OFFSET,STDFrame,
                          CANOBJECTTYPETX,0,
                          CAN_MSG_OBJ_NO_FLAGS);

        CANMSGObjectSetup(VSECC_CAN_BASE,CANOBJ_G2PECCLIMITS1,
                          BaseAddress+PECC_LIMITS1_OFFSET,STDFrame,
                          CANOBJECTTYPETX,0,
                          CAN_MSG_OBJ_NO_FLAGS);

        CANMSGObjectSetup(VSECC_CAN_BASE,CANOBJ_G2PECCLIMITS2,
                          BaseAddress+PECC_LIMITS2_OFFSET,STDFrame,
                          CANOBJECTTYPETX,0,
                          CAN_MSG_OBJ_NO_FLAGS);

        CANMSGObjectSetup(VSECC_CAN_BASE,CANOBJ_G2PECCLIMITS3,
                          BaseAddress+PECC_LIMITS3_OFFSET,STDFrame,
                          CANOBJECTTYPETX,0,
                          CAN_MSG_OBJ_NO_FLAGS);

        CANMSGObjectSetup(VSECC_CAN_BASE,CANOBJ_G2STOPCHARGING,
                          BaseAddress+STOP_CHARGING_OFFSET,STDFrame,
                          CANOBJECTTYPETX,0,
                          CAN_MSG_OBJ_NO_FLAGS);
    }

}

//*****************************************************************************
//
//! @brief Send a PECCStatus1 message to VSECC
//!
//! @param status Pointer to the PECCStatus1_t structure containing the charging parameters.
//! @param BaseAddress Base address identifying whether the message belongs to CTRLGUN1 or CTRLGUN2.
//!
//! This function encodes multiple charging parameters into a 64-bit CAN message and sends it to VSECC.
//! The parameters include voltage, current, temperature, and operational states.
//!
//! The function applies scaling factors to convert floating-point values into integer representations,
//! and it packs data efficiently using bitwise operations. The message is sent to VSECC
//! using the appropriate CAN object ID for either CTRLGUN1 or CTRLGUN2.
//!
//! @return None.
//
//******************************************************************************
void SendtoVSECC_PECSStatus1(PECCStatus1_t *status,uint32_t BaseAddress)
{
    uint64_t rawData = 0;
    uint16_t drivenVoltage = (uint16_t)(status->drivenVoltage * FACTOR_VOLTAGE);
    uint16_t drivenCurrent = (uint16_t)(status->drivenCurrent * FACTOR_CURRENT);
    uint16_t temperature   = (uint16_t)(status->temperature * FACTOR_TEMPERATURE);

    rawData |= ((uint64_t)status->contactorsStatus & 0x1) << 0;
    rawData |= ((uint64_t)status->operationalStatus & 0x1) << 1;
    rawData |= ((uint64_t)status->isolationStatus & 0xFF) << 2;
    rawData |= ((uint64_t)drivenVoltage & 0xFFFF) << 8;
    rawData |= ((uint64_t)drivenCurrent & 0xFFFF) << 24;
    rawData |= ((uint64_t)temperature & 0xFFFF) << 40;

    if (BaseAddress== CTRLGUN1)
    {
    CANSendMessage(VSECC_CAN_BASE,
                   CANOBJ_G1PECCSTATUS1,
                    &rawData,
                    DLC_PECCSTATUS1);
    }
    if (BaseAddress== CTRLGUN2)
    {
    CANSendMessage(VSECC_CAN_BASE,
                   CANOBJ_G2PECCSTATUS1,
                    &rawData,
                    DLC_PECCSTATUS1);
    }

}

//*****************************************************************************
//
//! @brief Send a PECCStatus2 message to VSECC
//!
//! @param status Pointer to the PECCStatus2_t structure containing measured voltage, current, and status.
//! @param BaseAddress Base address identifying whether the message belongs to CTRLGUN1 or CTRLGUN2.
//!
//! This function encodes measured electrical parameters into a 64-bit CAN message and sends it to VSECC.
//! It converts the floating-point values of voltage and current into integer representations using
//! predefined scaling factors. The packed message includes measured voltage, measured current,
//! and status information.
//!
//! The function then sends the message to VSECC using the appropriate CAN object ID based on the BaseAddress.
//!
//! @return None.
//
//*****************************************************************************
void SendtoVSECC_PECSStatus2(PECCStatus2_t *status,uint32_t BaseAddress)
{
    uint64_t rawData = 0;
    uint16_t measuredVoltage = (uint16_t)(status->measuredVoltage * FACTOR_VOLTAGE);
    uint16_t measuredCurrent = (uint16_t)(status->measuredCurrent * FACTOR_CURRENT);

    rawData |= ((uint64_t)measuredVoltage & 0xFFFF) << 0;
    rawData |= ((uint64_t)measuredCurrent & 0xFFFF) << 16;
    rawData |= ((uint64_t)status->status & 0xFFFF) << 32;

    if (BaseAddress== CTRLGUN1)
    {
        CANSendMessage(VSECC_CAN_BASE,
                   CANOBJ_G1PECCSTATUS2,
                    &rawData,
                    DLC_PECCSTATUS2);
    }
    if (BaseAddress== CTRLGUN2)
    {
        CANSendMessage(VSECC_CAN_BASE,
                       CANOBJ_G2PECCSTATUS2,
                       &rawData,
                       DLC_PECCSTATUS2);

    }
}

//*****************************************************************************
//
//! @brief Send PECCLimits1 message to VSECC
//!
//! @param limits Pointer to the PECCLimits1_t structure containing voltage and power limits.
//! @param BaseAddress Base address identifying whether the message belongs to CTRLGUN1 or CTRLGUN2.
//!
//! This function encodes power and voltage limit parameters into a 64-bit CAN message and sends it to VSECC.
//! It converts floating-point values of minimum and maximum voltage and power into integer representations
//! using predefined scaling factors. The packed message includes:
//! - Minimum voltage limit
//! - Maximum voltage limit
//! - Maximum power limit
//! - Minimum power limit
//!
//! The function then sends the message to VSECC using the appropriate CAN object ID based on the BaseAddress.
//!
//! @return None.
//
//*****************************************************************************
void SendtoVSECC_PECSLimits1(PECCLimits1_t *limits,uint32_t BaseAddress)
{
    uint64_t rawData = 0;
    uint16_t limitVoltageMin = (uint16_t)(limits->limitVoltageMin * FACTOR_VOLTAGE);
    uint16_t limitVoltageMax = (uint16_t)(limits->limitVoltageMax * FACTOR_VOLTAGE);
    uint16_t limitPowerMax = (uint16_t)(limits->limitPowerMax * FACTOR_POWER);
    uint16_t limitPowerMin = (uint16_t)(limits->limitPowerMin * FACTOR_POWER);

    rawData |= ((uint64_t)limitVoltageMin & 0xFFFF) << 0;
    rawData |= ((uint64_t)limitVoltageMax & 0xFFFF) << 16;
    rawData |= ((uint64_t)limitPowerMax & 0xFFFF) << 32;
    rawData |= ((uint64_t)limitPowerMin & 0xFFFF) << 48;

    if (BaseAddress== CTRLGUN1)
       {
        CANSendMessage(VSECC_CAN_BASE,
                   CANOBJ_G1PECCLIMITS1,
                   &rawData,
                    DLC_PECCLIMITS1);
       }
    if (BaseAddress== CTRLGUN2)
       {
        CANSendMessage(VSECC_CAN_BASE,
                       CANOBJ_G2PECCLIMITS1,
                       &rawData,
                       DLC_PECCLIMITS1);
       }
}

//*****************************************************************************
//
//! @brief Send PECCLimits2 message to VSECC
//!
//! @param limits Pointer to the PECCLimits2_t structure containing current limits.
//! @param BaseAddress Base address identifying whether the message belongs to CTRLGUN1 or CTRLGUN2.
//!
//! This function encodes current limit parameters into a 64-bit CAN message and sends it to VSECC.
//! It converts floating-point values of minimum and maximum current into integer representations
//! using predefined scaling factors. The packed message includes:
//! - Minimum current limit
//! - Maximum current limit
//!
//! The function then sends the message to VSECC using the appropriate CAN object ID based on the BaseAddress.
//!
//! @return None.
//
//*****************************************************************************
void SendtoVSECC_PECSLimits2(PECCLimits2_t *limits,uint32_t BaseAddress)
{
    uint64_t rawData =0;
    uint16_t limitCurrentMin = (uint16_t)(limits->limitCurrentMin * FACTOR_CURRENT);
    uint16_t limitCurrentMax = (uint16_t)(limits->limitCurrentMax * FACTOR_CURRENT);
    rawData |= ((uint64_t)limitCurrentMin & 0xFFFF) << 0;
    rawData |= ((uint64_t)limitCurrentMax & 0xFFFF) << 16;

    if (BaseAddress== CTRLGUN1)
    {
        CANSendMessage(VSECC_CAN_BASE,
                   CANOBJ_G1PECCLIMITS2,
                    &rawData,
                    DLC_PECCLIMITS2);
    }
    if (BaseAddress== CTRLGUN2)
    {
        CANSendMessage(VSECC_CAN_BASE,
                   CANOBJ_G2PECCLIMITS2,
                    &rawData,
                    DLC_PECCLIMITS2);
    }

}

//*****************************************************************************
//
//! @brief Send PECCLimits3 message to VSECC
//!
//! @param limits Pointer to the PECCLimits3_t structure containing discharge current and discharge power limits.
//! @param BaseAddress Base address identifying whether the message belongs to CTRLGUN1 or CTRLGUN2.
//!
//! This function encodes power and current discharge limit parameters into a 64-bit CAN message and sends it to VSECC.
//! It converts floating-point values of minimum and maximum current and power discharging limits into integer representations
//! using predefined scaling factors. The packed message includes:
//! - Minimum current discharge limit
//! - Maximum current discharge limit
//! - Minimum power discharge limit
//! - Maximum power discharge limit
//!
//! The function then sends the message to VSECC using the appropriate CAN object ID based on the BaseAddress.
//!
//! @return None.
//
//*****************************************************************************
void SendtoVSECC_PECSLimits3(PECCLimits3_t *limits,uint32_t BaseAddress)
{
    uint64_t rawData = 0;
    uint16_t limitDischargeCurrentMin = (uint16_t)(limits->limitDischargeCurrentMin * FACTOR_DISCHARGE_CURRENT);
    uint16_t limitDischargeCurrentMax = (uint16_t)(limits->limitDischargeCurrentMax * FACTOR_DISCHARGE_CURRENT);
    uint16_t limitDischargePowerMin   = (uint16_t)(limits->limitDischargePowerMin * FACTOR_DISCHARGE_POWER);
    uint16_t limitDischargePowerMax   = (uint16_t)(limits->limitDischargePowerMax * FACTOR_DISCHARGE_POWER);


    // Pack into rawData
    rawData |= ((uint64_t)limitDischargeCurrentMin & 0xFFFF) << 0;
    rawData |= ((uint64_t)limitDischargeCurrentMax & 0xFFFF) << 16;
    rawData |= ((uint64_t)limitDischargePowerMin   & 0xFFFF) << 32;
    rawData |= ((uint64_t)limitDischargePowerMax   & 0xFFFF) << 48;
    if (BaseAddress== CTRLGUN1)
    {
        CANSendMessage(VSECC_CAN_BASE,
                   CANOBJ_G1PECCLIMITS3,
                    &rawData,
                    DLC_PECCLIMITS3);
    }
    if (BaseAddress== CTRLGUN2)
        {
            CANSendMessage(VSECC_CAN_BASE,
                       CANOBJ_G2PECCLIMITS3,
                        &rawData,
                        DLC_PECCLIMITS3);
        }
}

//*****************************************************************************
//
//! @brief It gives the minimum and maximum values of voltage, current, and power information
//! to the SendtoVSECC_PECSLimits2 and SendtoVSECC_PECSLimits1 functions.
//!
//! @param Base_Address Base address defining the control gun (e.g., CTRLGUN1 or CTRLGUN2).
//! @param Vmin Minimum allowable volatge limit (in volts).
//! @param Vmax Maximum allowable voltage limit (in volts).
//! @param Imin Minimum allowable current limit (in amperes).
//! @param Imax Maximum allowable current limit (in amperes).
//! @param Pmax Maximum allowable power output (in watts).
//! @param Pmin Minimum allowable power output (in watts).
//!
//! This function gives the minimum and maximum voltage, current, and power
//! limits to the VSECC_PECSLimits2 and SendtoVSECC_PECSLimits1 functions.
//! These limits ensure that the charging or discharging process remains within
//! safe and efficient operating conditions. The data is encoded appropriately
//! before transmission.
//!
//! The function determines whether the message should be sent for control
//! gun 1 (CTRLGUN1) or control gun 2 (CTRLGUN2) based on the Base_Address parameter.
//!
//! @return None.
//
//*****************************************************************************
void SendVIPMinMaxLimtis(uint32_t Base_Address,float Vmin,float Vmax,float Imin,float Imax,float Pmin,float Pmax)
{
    PECCLimits2_t PECCLimits2;
    PECCLimits1_t PECCLimits1;

    PECCLimits1.limitPowerMax  =Pmax;
    PECCLimits1.limitPowerMin  =Pmin;
    PECCLimits1.limitVoltageMax  =Vmax;
    PECCLimits1.limitVoltageMin  =Vmin;
    PECCLimits2.limitCurrentMax  =Imax;
    PECCLimits2.limitCurrentMin  =Imin;
    SendtoVSECC_PECSLimits2(&PECCLimits2,Base_Address);
    SendtoVSECC_PECSLimits1(&PECCLimits1,Base_Address);

}

//*****************************************************************************
/**
// @brief It gives the charge status information to the SendtoVSECC_PECSStatus1 function.
//
// @param gunNumber Identifier for the charging gun (e.g., 1 for CTRLGUN1, 2 for CTRLGUN2).
// @param ContactorStatus Status of the contactors (open/closed) during charging.
// @param OperationsStatus Current operational state of the charging station.
// @param IsolationStatus Isolation monitoring status indicating safety compliance.
// @param DrivenVoltage Measured voltage being supplied to the vehicle (in volts).
// @param DrivenCurrent Measured current being delivered to the vehicle (in amperes).
// @param Temperature Temperature reading of the charging system (in degrees Celsius).
//
// This function gives the real-time charging status information to the
// SendtoVSECC_PECSStatus1 function. The status parameters include the state of
// contactors, the operational mode, isolation safety status, as well as  key
// electrical parameters such as voltage, current, and temperature.
//
// The function determines whether the message is sent for control gun 1 (CTRLGUN1)
// or control gun 2 (CTRLGUN2) based on the gunNumber parameter.
//
// @return None.

******************************************************************************/
void SendChargeStatus(uint32_t gunNumber,contactorsStatus_t ContectorStatus,
                      operationalStatus_t OperationsStatus,isolationStatus_t IsolationStatus,
                      float DrivenVoltage,float DrivenCurrent,float Temprature)
{
    PECCStatus1_t PECCStatus1;
    PECCStatus1.contactorsStatus = ContectorStatus;
    PECCStatus1.operationalStatus =  OperationsStatus;
    PECCStatus1.isolationStatus = IsolationStatus;
    PECCStatus1.drivenVoltage=DrivenVoltage;
    PECCStatus1.drivenCurrent=DrivenCurrent;
    PECCStatus1.temperature=Temprature;
    SendtoVSECC_PECSStatus1(&PECCStatus1,gunNumber);

}

/**
* @brief It gives the measured voltage and current information to the SendtoVSECC_PECSStatus2 function.
*
* @param Measured voltage being supplied to the vehicle (in volts).
* @param Measured current being delivered to the vehicle (in amperes).
*
* This function gives the real-time measured voltage and current information to the
* SendtoVSECC_PECSStatus2 function. The status parameters include the measured current and voltage.
*
* The function determines whether the message should be sent for control gun 1 (CTRLGUN1) or control gun 2 (CTRLGUN2)
* based on the Base_Address parameter.
* @return None.
*/
void SendPECCMesuredValue(uint32_t gunNumber, float MesuredVoltage,float MesureCurrent)
{
    PECCStatus2_t PECCStatus2;
    PECCStatus2.measuredCurrent= MesureCurrent;
    PECCStatus2.measuredVoltage=MesuredVoltage;
    SendtoVSECC_PECSStatus2(&PECCStatus2,gunNumber);

}

//*****************************************************************************
//
//! @brief Send StopCharging command to VSECC
//!
//! @param BaseAddress - The VSECC base address of the charging gun (e.g., CTRLGUN1 base address, CTRLGUN2 base address).
//!
//! This function sends a stop charging command to the VSECC (Vehicle-to-Station
//! Electronic Communication Controller) over the CAN bus. It prepares the CAN
//! message and transmits it, instructing the charging station to **stop supplying power**.
//!
//! @return None.
//
//*****************************************************************************
void SendtoVSECC_PECSStopCharging(uint32_t BaseAddress)
{
    if (BaseAddress== CTRLGUN1)
    {
        CANSendMessage(VSECC_CAN_BASE,
                   CANOBJ_G1STOPCHARGING,
                    NULL,
                    DLC_STOPCHARGING);
    }
    if (BaseAddress== CTRLGUN2)
    {
        CANSendMessage(VSECC_CAN_BASE,
                   CANOBJ_G2STOPCHARGING,
                    NULL,
                    DLC_STOPCHARGING);
    }
}

/**
 *  @brief This function process the can id received from VSECC, based on can id it gives the data and length to a specific
 *  process function.
 *
 *  @brief 'can_id' It is a combination of base address and offset id of specific process function.
 *  @param 'data' Pointer to the received vehicle status data.
 *  @param 'length' Length of the received data in bytes.
 *  @param 'receivedData' Pointer to a structure where the extracted vehicle status information will be stored.
 *
 *  This function process the can id received from VSECC, based on can id it gives the data and length to a specific
 *  process function to extract the data and extracted data stores it in the provided `receivedData` structure.
 *
 *  @return None.
 */
void VSECC_ProcessCANMsg(uint32_t can_id, uint8_t *data, uint8_t length, ReceiveFromVSECCStruct *receivedData)
{
    //VSECCStatus_t current_state;
    //VSECC_status previous_state;
    if (receivedData == NULL || data == NULL) return;  // Null check
    uint32_t MSGBase =  can_id & MASKFORBASE;

    uint32_t MsgOffset = can_id & MASKFORMSG;
    if (MSGBase == CTRLGUN1 || MSGBase == CTRLGUN2)
    {
        switch (MsgOffset)
        {
            case VEHICLE_STATUS_OFFSET:
                if (length == DLC_VEHICLESTATUS)
                {
                    ProcessVehicleStatus(data, length, receivedData);
                    VSECCCount[0]++;
                }
                break;

            case VEHICLE_ID_OFFSET:
                if (length == DLC_VEHICLEID)
                {
                    ProcessVehicleId(data, length, receivedData);
                    VSECCCount[1]++;
                }
                break;

            case CHARGING_SESSION_INFO1_OFFSET:
                if (length == DLC_CHARGINGSESSIONINFO1)
                {
                    ProcessChargingSessionInfo1(data, length, receivedData);
                    VSECCCount[2]++;
                }
                break;

            case CHARGING_SESSION_INFO2_OFFSET:
                if (length == DLC_CHARGINGSESSIONINFO2)
                {
                    ProcessChargingSessionInfo2(data, length, receivedData);
                    VSECCCount[3]++;
                }
                break;

            case CHARGING_SESSION_INFO3_OFFSET:
                if (length == DLC_CHARGINGSESSIONINFO3)
                {
                    ProcessChargingSessionInfo3(data, length, receivedData);
                    VSECCCount[4]++;
                }
                break;

            case CHARGING_SESSION_INFO4_OFFSET:
                if (length == DLC_CHARGINGSESSIONINFO4)
                {
                    ProcessChargingSessionInfo4(data, length, receivedData);
                    VSECCCount[5]++;
                }
                break;
            case RESET_OFFSET:
                    ProcessResetCommand(receivedData);
                    VSECCCount[6]++;
                break;
           default:
                // Unknown CAN ID, ignore or log error
                break;
        }
    }
    else
    {
        switch (MsgOffset)
        {
            case ANALOG_INS1_OFFSET:
                if (length == DLC_ANALOGINS1)
                {
                    ProcessAnalogIns1(data, length, receivedData);
                    VSECCCount[7]++;
                }
                break;

            case ANALOG_INS2_OFFSET:
                if (length == DLC_ANALOGINS2) {
                    ProcessAnalogIns2(data, length, receivedData);
                    VSECCCount[8]++;
                }
                break;

            case ANALOG_INS3_OFFSET:
                if (length == DLC_ANALOGINS3) {
                    ProcessAnalogIns3(data, length, receivedData);
                    VSECCCount[9]++;
                }
                break;

            default:
                // Unknown CAN ID, ignore or log error
                break;
        }
    }

}

/**
 *  @brief Processes the vehicle status data received from the VSECC.
 *
 *  @param 'data' Pointer to the received vehicle status data.
 *  @param 'length' Length of the received data in bytes.
 *  @param 'receivedData' Pointer to a structure where the extracted vehicle status information will be stored.
 *
 *  This function processes the vehicle status data received from the VSECC (V Supply Equipment Communication Controller).
 *  It extracts the relevant information, such as contactors status, ev connection status, charging state,
 *  and other parameters, from the received CAN message and stores it in the provided `receivedData` structure.
 *
 *  The function ensures that the extracted values are correctly interpreted based on the message format.
 *  It plays a crucial role in monitoring and updating the real-time vehicle charging or discharging status.
 *
 *  @return None.
 */
void ProcessVehicleStatus(uint16_t *data, uint8_t length, ReceiveFromVSECCStruct *receivedData)
{
    uint64_t temp = 0;
    uint8_t *byteData = (uint8_t *)data;
    uint8_t i = 0;

    // Convert raw bytes into a 64-bit integer
    for (i = 0; i < length; i++)
    {
        temp |= ((uint64_t)byteData[i] << (8 * i));
    }
    // Assign raw data
    // Extract individual fields from rawData
    receivedData->VehicleStatus.targetContactorsStatus = (temp >> 0) & 0x01;
    receivedData->VehicleStatus.evConnectionState = (evConnectionState_t)((temp >> 1) & 0x03);
    receivedData->VehicleStatus.chargingState = (chargingState_t)((temp >> 3) & 0x07);
    receivedData->VehicleStatus.reserved1 = (temp >> 6) & 0x03;
    receivedData->VehicleStatus.targetVoltage = ((temp >> 8) & 0xFFFF) * 0.1f;
    receivedData->VehicleStatus.targetCurrent = ((temp >> 24) & 0xFFFF) * 0.1f;
    receivedData->VehicleStatus.batteryStateOfCharge = (temp >> 40) & 0x7F;
    receivedData->VehicleStatus.reserved2 = (temp >> 47) & 0x01;
    receivedData->VehicleStatus.cableCheckVoltage = ((temp >> 48) & 0xFFFF);
}

/**
 *  @brief Processes the vehicle ID received from the VSECC.
 *
 *  @param 'data' Pointer to the received vehicle ID data.
 *  @param 'length' Length of the received data in bytes.
 *  @param 'receivedData' Pointer to a structure where the extracted vehicle ID information will be stored.
 *
 *  This function processes the vehicle ID data received from the VSECC (V Supply Equipment Communication Controller).
 *  It extracts the vehicle ID from the received CAN message and stores it in the provided `receivedData` structure.
 *
 *  @return None.
 */
void ProcessVehicleId(uint8_t *data, uint8_t length, ReceiveFromVSECCStruct *receivedData) {
    uint64_t temp = 0;
    uint8_t i = 0;
    for (i = 0; i < DLC_VEHICLEID; i++)
    {
        temp = temp  |  ((uint64_t)data[i] & 0xFF)  << (8*i);
    }
    receivedData->VehicleID = temp;
}


/**
 *  @brief Processes the vehicle charging information-1 received from the VSECC.
 *
 *  @param 'data' Pointer to the received vehicle charging session information-1 data.
 *  @param 'length' Length of the received data in bytes.
 *  @param 'receivedData' Pointer to a structure where the extracted vehicle charging session information-1 will be stored.
 *
 *  This function processes the vehicle charging information data received from the VSECC (V Supply Equipment Communication Controller).
 *  It extracts the Maximum power limit and Time to full the charge from the received CAN message, and stores it in the provided
 *  `receivedData` structure.
 *
 *  @return None.
 */
void ProcessChargingSessionInfo1(uint8_t *data, uint8_t length, ReceiveFromVSECCStruct *receivedData) {
    receivedData->ChargingSessionInfo1.chargingProfileMaxPowerLimit = ((data[0]&0xFF) + ((data[1]&0xFF)<<8))*10;
    receivedData->ChargingSessionInfo1.timeToFullSoc =((data[2]&0xFF) + ((data[3]&0xFF)<<8));
}

/**
 *  @brief Processes the vehicle charging information-2 received from the VSECC.
 *
 *  @param 'data' Pointer to the received vehicle charging session information-2 data.
 *  @param 'length' Length of the received data in bytes.
 *  @param 'receivedData' Pointer to a structure where the extracted vehicle charging session information-2 will be stored.
 *
 *  This function processes the vehicle charging information data received from the VSECC (V Supply Equipment Communication Controller).
 *  It extracts the Maximum voltage, current and power of vehicle from the received CAN message, and stores it in the provided
 *  `receivedData` structure.
 *
 *  @return None.
 */
void ProcessChargingSessionInfo2(uint8_t *data, uint8_t length, ReceiveFromVSECCStruct *receivedData) {
    receivedData->ChargingSessionInfo2.evMaxVoltage = ((data[0]&0xFF) + ((data[1]&0xFF)<<8)) ;
    receivedData->ChargingSessionInfo2.evMaxCurrent = ((data[2]&0xFF) + ((data[3]&0xFF)<<8));
    receivedData->ChargingSessionInfo2.evMaxPower =   ((data[4]&0xFF) + ((data[5]&0xFF)<<8)) *1000.0f;
}

/**
 *  @brief Processes the vehicle charging information-3 received from the VSECC.
 *
 *  @param 'data' Pointer to the received vehicle charging session information-3 data.
 *  @param 'length' Length of the received data in bytes.
 *  @param 'receivedData' Pointer to a structure where the extracted vehicle charging session information-3 will be stored.
 *
 *  This function processes the vehicle charging information data received from the VSECC (V Supply Equipment Communication Controller).
 *  It extracts the Minimum voltage, current power and charge mode of vehicle from the received CAN message, and
 *  stores it in the provided `receivedData` structure.
 *
 *  @return None.
 */
void ProcessChargingSessionInfo3(uint8_t *data, uint8_t length, ReceiveFromVSECCStruct *receivedData) {
    uint64_t temp = 0;
    uint8_t i = 0;
    for (i = 0; i < DLC_CHARGINGSESSIONINFO3; i++) {
        ((uint8_t*)&temp)[i] = data[i];
    }

    receivedData->ChargingSessionInfo3.evMinVoltage = ((temp >> 0) & 0xFFFF) * 0.1f;
    receivedData->ChargingSessionInfo3.evMinCurrent = ((temp >> 16) & 0xFFFF) * 0.1f;
    receivedData->ChargingSessionInfo3.evMinPower = ((temp >> 32) & 0xFFFF) * 0.1f;
    receivedData->ChargingSessionInfo3.chargeMode = (chargeMode_t)((temp >> 48) & 0xFF);
}

/**
 *  @brief Processes the vehicle charging information-4 received from the VSECC.
 *
 *  @param 'data' Pointer to the received vehicle charging session information-4 data.
 *  @param 'length' Length of the received data in bytes.
 *  @param 'receivedData' Pointer to a structure where the extracted vehicle charging session information-4 will be stored.
 *
 *  This function processes the vehicle charging information data received from the VSECC (V Supply Equipment Communication Controller).
 *  It extracts the Minimum discharge of current, power and maximum discharge of current, power vehicle from the received
 *  CAN message, and stores it in the provided `receivedData` structure.
 *
 *  @return None.
 */
void ProcessChargingSessionInfo4(uint8_t *data, uint8_t length, ReceiveFromVSECCStruct *receivedData) {
    uint64_t temp = 0;
    uint8_t i = 0;
    for (i = 0; i < DLC_CHARGINGSESSIONINFO4; i++) {
        ((uint8_t*)&temp)[i] = data[i];
    }

    receivedData->ChargingSessionInfo4.evMinDischargeCurrent = ((temp >> 0) & 0xFFFF) * 0.1f;
    receivedData->ChargingSessionInfo4.evMaxDischargeCurrent = ((temp >> 16) & 0xFFFF) * 0.1f;
    receivedData->ChargingSessionInfo4.evMinDischargePower = ((temp >> 32) & 0xFFFF) * 0.1f;
    receivedData->ChargingSessionInfo4.evMaxDischargePower = ((temp >> 48) & 0xFFFF) * 0.1f;
}

/**
 *  @brief Processes the Analog inputs group-1 received from the VSECC.
 *
 *  @param 'data' Pointer to the received Analog information-1 data.
 *  @param 'length' Length of the received data in bytes.
 *  @param 'receivedData' Pointer to a structure where the extracted analog information-1 will be stored.
 *
 *  This function processes the vehicle charging information data received from the VSECC (V Supply Equipment Communication Controller).
 *  It extracts the temperature-1, temperature-2, temperature-3 and temperature-4 values from the received CAN message, and
 *  stores it in the provided `receivedData` structure.
 *
 *  @return None.
 */
void ProcessAnalogIns1(uint8_t *data, uint8_t length, ReceiveFromVSECCStruct *receivedData) {
    uint64_t temp = 0;
    uint8_t i = 0;
    for (i = 0; i < DLC_ANALOGINS1; i++) {
        ((uint8_t*)&temp)[i] = data[i];
    }

    receivedData->AnalogIns1.temperature1 = ((temp >> 0) & 0xFFFF) * 0.1f;
    receivedData->AnalogIns1.temperature2 = ((temp >> 16) & 0xFFFF) * 0.1f;
    receivedData->AnalogIns1.temperature3 = ((temp >> 32) & 0xFFFF) * 0.1f;
    receivedData->AnalogIns1.temperature4 = ((temp >> 48) & 0xFFFF) * 0.1f;
}

/**
 *  @brief Processes the Analog inputs group-2 received from the VSECC.
 *
 *  @param 'data' Pointer to the received Analog information-2 data.
 *  @param 'length' Length of the received data in bytes.
 *  @param 'receivedData' Pointer to a structure where the extracted analog information-2 will be stored.
 *
 *  This function processes the vehicle charging information data received from the VSECC (V Supply Equipment Communication Controller).
 *  It extracts the temperature-5, temperature-6, temperature-7, and temperature-8 values from the received CAN message,
 *  and stores it in the provided `receivedData` structure.
 *
 *  @return None.
 */
void ProcessAnalogIns2(uint8_t *data, uint8_t length, ReceiveFromVSECCStruct *receivedData) {
    uint64_t temp = 0;
    uint8_t i = 0;
    for (i = 0; i < DLC_ANALOGINS2; i++) {
        ((uint8_t*)&temp)[i] = data[i];
    }

    receivedData->AnalogIns2.temperature5 = ((temp >> 0) & 0xFFFF) * 0.1f;
    receivedData->AnalogIns2.temperature6 = ((temp >> 16) & 0xFFFF) * 0.1f;
    receivedData->AnalogIns2.temperature7 = ((temp >> 32) & 0xFFFF) * 0.1f;
    receivedData->AnalogIns2.temperature8 = ((temp >> 48) & 0xFFFF) * 0.1f;
}

/**
 *  @brief Processes the Analog inputs group-3 received from the VSECC.
 *
 *  @param 'data' Pointer to the received Analog information-3 data.
 *  @param 'length' Length of the received data in bytes.
 *  @param 'receivedData' Pointer to a structure where the extracted analog information-3 will be stored.
 *
 *  This function processes the vehicle charging information data received from the VSECC (Vehicle Smart Energy Control Center).
 *  It extracts the temperature and two other analog values from the received CAN message, and stores it in the provided
 *  `receivedData` structure.
 *
 *  @return None.
 */
void ProcessAnalogIns3(uint8_t *data, uint8_t length, ReceiveFromVSECCStruct *receivedData) {
    uint64_t temp = 0;
    uint8_t i = 0;
    for (i = 0; i < DLC_ANALOGINS3; i++) {
        ((uint8_t*)&temp)[i] = data[i];
    }

    receivedData->AnalogIns3.temperature9 = ((temp >> 0) & 0xFFFF) * 0.1f;
    receivedData->AnalogIns3.ain1 = ((temp >> 16) & 0xFFFF) * 0.1f;
    receivedData->AnalogIns3.ain2 = ((temp >> 32) & 0xFFFF) * 0.1f;
}

/**
 *  @brief It is used to reset the charging station
 *
 *  This function does not have a data and length, this is a command to rest or restart the charging station.
 *
 *  @return None.
 */
void ProcessResetCommand(ReceiveFromVSECCStruct *receivedData) {
    receivedData->ResetCommand = 1;
}

void VSECCCANCyclicCheck(VSECCStatus_t VseccStatus)
{
    uint8_t i;
    for(i=0;i<10;i++)
    {
        switch(i)
        {
        case 0:
            CheckOperation(&VSECCCount[i],&VseccStatus.VEHICLE_STATUS,&VSECCRegularityCheck[i]);
            break;
        case 1:
            CheckOperation(&VSECCCount[i],&VseccStatus.VEHICLE_ID,&VSECCRegularityCheck[i]);
            break;
        case 2:
            CheckOperation(&VSECCCount[i],&VseccStatus.CHARGING_SESSION_INFO1,&VSECCRegularityCheck[i]);
            break;
        case 3:
            CheckOperation(&VSECCCount[i],&VseccStatus.CHARGING_SESSION_INFO2,&VSECCRegularityCheck[i]);
            break;
        case 4:
            CheckOperation(&VSECCCount[i],&VseccStatus.CHARGING_SESSION_INFO3,&VSECCRegularityCheck[i]);
            break;
        case 5:
            CheckOperation(&VSECCCount[i],&VseccStatus.CHARGING_SESSION_INFO4,&VSECCRegularityCheck[i]);
            break;
        case 6:
            CheckOperation(&VSECCCount[i],&VseccStatus.RESET,&VSECCRegularityCheck[i]);
            break;
        case 7:
            CheckOperation(&VSECCCount[i],&VseccStatus.ANALOG_INS1,&VSECCRegularityCheck[i]);
            break;
        case 8:
            CheckOperation(&VSECCCount[i],&VseccStatus.ANALOG_INS2,&VSECCRegularityCheck[i]);
            break;
        case 9:
            CheckOperation(&VSECCCount[i],&VseccStatus.ANALOG_INS3,&VSECCRegularityCheck[i]);
            break;
        }
    }
}

void CheckOperation(uint8_t *count,VSECC_StatusMode_t *status,uint8_t *Ireg_check)
{
    if((*Ireg_check>=TIME2) && (*count < COUNTCHECK)){
        *status = ERROR;
        *Ireg_check=9;
    }
    else if((*Ireg_check>=TIME1) && (*Ireg_check < TIME2)  && (*count < COUNTCHECK)){
        *status = NOT_RESPONDIND;
        (*Ireg_check)++;
    }
    else if(*count < COUNTCHECK){
        *status = Cyclic_OUT;
        (*Ireg_check)++;
    }
    else if(*count >= COUNTCHECK){
        *status = Cyclic_OK;
        *count=1;
        *Ireg_check = 1;
    }
}
